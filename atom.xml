<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://seaony.github.io</id>
    <title>Seaony&apos; Blog</title>
    <updated>2023-04-21T11:50:31.209Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://seaony.github.io"/>
    <link rel="self" href="https://seaony.github.io/atom.xml"/>
    <subtitle>一定要有所失，才能有所悟吗？</subtitle>
    <logo>https://seaony.github.io/images/avatar.png</logo>
    <icon>https://seaony.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Seaony&apos; Blog</rights>
    <entry>
        <title type="html"><![CDATA[🎃 小李是中国人 (单词 + 语法)]]></title>
        <id>https://seaony.github.io/post/di-yi-ke/</id>
        <link href="https://seaony.github.io/post/di-yi-ke/">
        </link>
        <updated>2023-04-20T15:46:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基本单词">🧶 基本单词</h2>
<ul>
<li>
<p><u><strong>ちゅうごくじん</strong></u> (4)</p>
<p>词义：中国人</p>
</li>
<li>
<p><u><strong>にほんじん</strong></u> (4)</p>
<p>词义：日本人</p>
</li>
<li>
<p><u><strong>かんこくじん</strong></u> (4)</p>
<p>词义：韩国人</p>
</li>
<li>
<p><u><strong>あめりかじん</strong></u> (4)</p>
<p>词义：美国人</p>
</li>
<li>
<p><u><strong>ふらんすじん</strong></u> (4)</p>
<p>词义：法国人</p>
</li>
<li>
<p><u><strong>がくせい</strong></u> (0)</p>
<p>词义：学生</p>
</li>
<li>
<p><u><strong>りゅうがくせい</strong></u> (3)</p>
<p>词义：留学生</p>
</li>
<li>
<p><u><strong>きょうじゅ</strong></u> (0)</p>
<p>词义：教授</p>
</li>
<li>
<p><u><strong>しゃいん</strong></u> (1)</p>
<p>词义：职员</p>
</li>
<li>
<p><u><strong>かいしゃいん</strong></u> (3)</p>
<p>词义：公司职员</p>
</li>
<li>
<p><u><strong>てんいん</strong></u> (0)</p>
<p>词义：店员</p>
</li>
<li>
<p><u><strong>けんしゅうせい</strong></u> (3)</p>
<p>词义：进修生</p>
</li>
<li>
<p><u><strong>きぎょう</strong></u> (1)</p>
<p>词义：企业</p>
</li>
<li>
<p><u><strong>だいがく</strong></u> (0)</p>
<p>词义：大学</p>
</li>
<li>
<p><u><strong>ちち</strong></u> (1/２)</p>
<p>词义：父亲</p>
</li>
<li>
<p><u><strong>かちょう</strong></u> (0)</p>
<p>词义：科长</p>
</li>
<li>
<p><u><strong>しゃちょう</strong></u> (0)</p>
<p>词义：总经理</p>
</li>
<li>
<p><u><strong>でむかえ</strong></u> (0)</p>
<p>词义：迎接</p>
</li>
<li>
<p><u><strong>あのひと</strong></u> (2)</p>
<p>词义：那个人</p>
</li>
<li>
<p><u><strong>わたし</strong></u> (0)</p>
<p>词义：我</p>
</li>
<li>
<p><u><strong>あなた</strong></u> (2)</p>
<p>词义：你</p>
</li>
<li>
<p><u><strong>どうも</strong></u> (1)</p>
<p>词义：非常、很</p>
</li>
<li>
<p><u><strong>はい</strong></u> (1)</p>
<p>词义：是的</p>
</li>
<li>
<p><u><strong>いいえ</strong></u> (3)</p>
<p>词义：不，不是</p>
</li>
<li>
<p><u><strong>あつ</strong></u></p>
<p>词义：哎，哎呀</p>
</li>
<li>
<p><u><strong>り</strong></u></p>
<p>词义：李</p>
</li>
<li>
<p><u><strong>おう</strong></u> (1)</p>
<p>词义：王</p>
</li>
<li>
<p><u><strong>ちょ</strong></u> (1)</p>
<p>词义：张</p>
</li>
<li>
<p><u><strong>もり</strong></u> (0)</p>
<p>词义：森</p>
</li>
<li>
<p><u><strong>はやし</strong></u> (0)</p>
<p>词义：林</p>
</li>
<li>
<p><u><strong>おの</strong></u> (0)</p>
<p>词义：小野</p>
</li>
<li>
<p><u><strong>よしだ</strong></u> (0)</p>
<p>词义：吉田</p>
</li>
<li>
<p><u><strong>たなか</strong></u> (0)</p>
<p>词义：田中</p>
</li>
<li>
<p><u><strong>なかむら</strong></u> (0)</p>
<p>词义：中村</p>
</li>
<li>
<p><u><strong>たろう</strong></u> (1)</p>
<p>词义：太郎</p>
</li>
<li>
<p><u><strong>キム</strong></u> (1)</p>
<p>词义：金</p>
</li>
<li>
<p><u><strong>でゅぽん</strong></u> (1)</p>
<p>词义：ヂュポン (迪蓬)</p>
</li>
<li>
<p><u><strong>すみす</strong></u> (1)</p>
<p>词义：スミス/斯密斯</p>
</li>
<li>
<p><u><strong>じょんそん</strong></u> (1)</p>
<p>词义：ジョンソn/约翰逊</p>
</li>
<li>
<p><u><strong>ちゅうごく</strong></u> (1)</p>
<p>词义：中国</p>
</li>
<li>
<p><u><strong>とうきょうだいがく</strong></u> (1)</p>
<p>词义：東京大学</p>
</li>
<li>
<p><u><strong>ぺきんだいがく</strong></u> (1)</p>
<p>词义：北京大学</p>
</li>
<li>
<p><u><strong>ジェーシーきかく</strong></u> (1)</p>
<p>词义：JC策划公司</p>
</li>
<li>
<p><u><strong>ぺきんりょにうしゃ</strong></u> (5)</p>
<p>词义：北京旅行社</p>
</li>
<li>
<p><u><strong>にちゅうしょうじ</strong></u> (5)</p>
<p>词义：日中商事</p>
</li>
<li>
<p><u><strong>こっにちは</strong></u> (5)</p>
<p>词义：你好</p>
</li>
<li>
<p><u><strong>すみません</strong></u> (4)</p>
<p>词义：对不起</p>
</li>
<li>
<p><u><strong>どんぞ</strong></u> (1)</p>
<p>词义：请</p>
</li>
<li>
<p><u><strong>〜さん、くん</strong></u></p>
<p>词义：先生、小姐</p>
</li>
<li>
<p><u><strong>はじめまして</strong></u> (4)</p>
<p>词义：初次见面</p>
</li>
<li>
<p><u><strong>こちらこそ</strong></u> (4)</p>
<p>词义：我才要 (请您)</p>
</li>
<li>
<p><u><strong>そうです</strong></u> (1)</p>
<p>词义：是 (这样)</p>
</li>
<li>
<p><u><strong>ちがいます</strong></u> (4)</p>
<p>词义：不是</p>
</li>
<li>
<p><u><strong>わかりません</strong></u> (5)</p>
<p>词义：不是</p>
</li>
</ul>
<hr>
<h2 id="语法">🍻 语法</h2>
<ol>
<li>
<p><u><strong>名は　名です</strong></u> （AはBです）</p>
<p>相当于汉语的 “～是～”。“～は” 是主语部分，“です” 是谓语部分。</p>
<p>助词 “は” 用于提示主题，读作 “わ”。</p>
<p>▲　李さんは　中国人です。（小李是中国人。）</p>
<p>▲　わたしは　日本人です。（我是日本人。）</p>
<p>▲　わたしは　王です。（我姓王。）</p>
<p>▲　わたしは　がくせんです。私は　学生です。（我是学生。）</p>
</li>
<li>
<p><u><strong>名は　名ではありません</strong></u> （AはBではありません）</p>
<p>相当于汉语 “～不是～”。“では ありません” 的 “では” 在口语中有时候会发成 “じゃ”</p>
<p>▲　森さんは　学生ではありません。（森先生不是学生。）</p>
<p>▲　わたしは　日本人ではありません。（我不是日本人。）</p>
<p>▲　わたしわ　田中じゃありません。（我不是田中。）</p>
<p>▲　私わ　小学生では　ありません（我不是小学生。）</p>
</li>
<li>
<p><u><strong>名は　名ですか</strong></u> （AはBですか）</p>
<p>相当于汉语的 “～是～吗？”</p>
<p>助词 “か” 接在句尾表示疑问。日语的问句在句尾不使用 “？”。</p>
<p>回答是可以只用 “はい” 或 “いいえ”。</p>
<p>▲　あなたは小野さんですか。（您是小野女士吗？）<br>
ーーはい、小野です。（是的，我是小野。）</p>
<p>▲　キムさん中国人ですか。（金女士是中国人吗？）<br>
ーーいいえ、中国人では　ありますん。（不，不是中国人）</p>
</li>
<li>
<p><u><strong>名の名</strong></u> [从属机构、国家][属性] （AのB）</p>
<p>一般情况下相当于汉语的 “的” 的意思。</p>
<p>助词 “の” 连接名词和名词，表示前面的名词是后面名词从属的机构、国家或属性。</p>
<p>▲　李さんはJC区画の社員。（小李是JC策划公司的职员）</p>
<p>▲　北京旅行社は中国の企画です。（北京旅行社是中国的企业）</p>
</li>
</ol>
<h2 id="表达语及词语">👨‍💻 表达语及词语</h2>
<ol>
<li>
<p><u><strong>人称</strong></u></p>
<ul>
<li>
<p><strong>“わたし”、“あなた”、“あの人”</strong></p>
</li>
<li>
<p><strong>“～さん”</strong></p>
</li>
</ul>
</li>
<li>
<p><u><strong>省略</strong></u></p>
</li>
<li>
<p><u><strong>あっ</strong></u> [叹词]</p>
</li>
<li>
<p><u><strong>どうぞ、よろしく　お願いします</strong></u> [多多关照]</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[🚍 日语声调 - [日语学习笔记]]]></title>
        <id>https://seaony.github.io/post/ri-yu-sheng-diao-ri-yu-xue-xi-bi-ji/</id>
        <link href="https://seaony.github.io/post/ri-yu-sheng-diao-ri-yu-xue-xi-bi-ji/">
        </link>
        <updated>2023-04-20T14:17:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是声调">🫠 什么是声调</h2>
<p>日语词语中的各个音节之间存在的高低、轻重的配置关系叫做<strong>声调</strong>（アクセント），声调可以用来<strong>区分同音词</strong>。与中文的四声声调不同，日语是<strong>高低型声调</strong>，发音是“由低到高”“由高到低”的状态，单词中某些音节为高音，某些音节为低音。</p>
<hr>
<h2 id="声调规则">🧶 声调规则</h2>
<ol>
<li>
<p><u><strong>第一个音与第二音不是同音</strong></u></p>
</li>
<li>
<p><u><strong>出现降音就不会升回去</strong></u></p>
</li>
<li>
<p><u><strong>在第几个音出现，就是几型</strong></u></p>
</li>
</ol>
<hr>
<h2 id="声调类型">🪴 声调类型</h2>
<p>日语的声调可以分为平板型和起伏型，起伏型又分为头高型、中高型、尾高型。</p>
<ol>
<li>
<p><strong>平板型</strong></p>
<p>第一个音节低，后面音都高。后续助词为高音，这种类型中由三至四个音节组成的词较多。</p>
</li>
<li>
<p><u><strong>头高型</strong></u></p>
<p>第一个音节高，后面音都低。</p>
</li>
<li>
<p><u><strong>中高型</strong></u></p>
<p>第一个和最后一个音节低，中间为高音（分全为高音节和部分为高音节）。后续助词为低音这种类型中没有一个或两个音节的词，三个音节以上才会出现。</p>
</li>
<li>
<p><u><strong>尾高型</strong></u></p>
<p>第一个音节低，第二个音开始都为高音节。后续助词为低音。</p>
</li>
</ol>
<blockquote>
<p>在日语中一个假名代表一拍，包括表示清音、浊音、半浊音、促音っ、拨音ん以及长音的假名，但是不包括组成拗音中的小“ゃ”、“ゅ”和“ょ”，即一个拗音整体上作为一个音拍来看待，如“きゃ”是一个音拍，而不是两拍。而“きょう”和“そう”等长音则是两拍。</p>
</blockquote>
<hr>
<h2 id="长音规则">🍻 长音规则</h2>
<ol>
<li>
<p>“あ”、“い”、“う”段假名分别在其后加“あ”、“い”、“う”构成长音。</p>
</li>
<li>
<p>“え”段假名在其后加“い”构成长音。但是个别单词中也有加“え”的。</p>
</li>
<li>
<p>“お”段假名在其后加“う”构成长音。但是个别单词中也有加“お”的。</p>
</li>
<li>
<p>用片假名书写的外来语用长音符号“一”来表示。</p>
</li>
<li>
<p>用罗马字标记时，既可以在元音上标注“一”来表示长音，也可以通过双写元音字母来表示长音。</p>
</li>
</ol>
<blockquote>
<p>あ段假名后加あ，如：おかあさんい段假名后加い，如：おにいさんう段假名后加う，如：つうやくえ段假名后加い，如：せんせいお段假名后加う，如：おとうさん外来语长音用ー表示：如：ノート 另外，特殊场合下：え段假名后加え，如：おねえさんお段假名后加お，如：おおきい。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[🎃 iOS Swift 项目实现多语言支持]]></title>
        <id>https://seaony.github.io/post/ios-swift-xiang-mu-shi-xian-duo-yu-yan-zhi-chi/</id>
        <link href="https://seaony.github.io/post/ios-swift-xiang-mu-shi-xian-duo-yu-yan-zhi-chi/">
        </link>
        <updated>2023-04-16T11:11:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="️-创建文件">😶‍🌫️ 创建文件</h2>
<p>在项目根目录下右键选择 <code>New File</code>，创建一个名为 <code>Localizable.strings</code> 的 Strings File。</p>
<figure data-type="image" tabindex="1"><img src="https://seaony.github.io/post-images/1681668230963.png" alt="" loading="lazy"></figure>
<p>在 <code>Localizable.strings</code> 中添加你的多语言文本，它看起来就像这样。</p>
<pre><code class="language-swift">// 示例文本
ExampleMessage = &quot;Example Message&quot;;
</code></pre>
<h2 id="使用文本">🪴 使用文本</h2>
<p>接下来，你可以像这样使用它：</p>
<pre><code class="language-swift">/// - NSlocalizedString
NSlocalizedString(&quot;ExampleMessage&quot;, comment: &quot;&quot;)
 // Example Message

 /// - R.swift
 R.string.localizable.exampleMessage()
  // Example Message
</code></pre>
<hr>
<h2 id="启用国际化">👨‍💻 启用国际化</h2>
<p>选中项目 <code>Project Info</code>，在 <code>Localizations</code> 中点击加号，添加你想要支持的语言。</p>
<figure data-type="image" tabindex="2"><img src="https://seaony.github.io/post-images/1681668335176.png" alt="" loading="lazy"></figure>
<hr>
<h2 id="app-名称国际化">📚 App 名称国际化</h2>
<p>创建 <code>InfoPlist.strings</code> 文件，点击右侧 <code>localize</code>，然后选择对应的语言。</p>
<p>接着在文件中设置对应语言的 App 名称:</p>
<pre><code class="language-swift">CFBundleName=&quot;Your App Name&quot;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[🧶 自建 StableDiffusion 流程分享]]></title>
        <id>https://seaony.github.io/post/zi-jian-stablediffusion-liu-cheng-fen-xiang/</id>
        <link href="https://seaony.github.io/post/zi-jian-stablediffusion-liu-cheng-fen-xiang/">
        </link>
        <updated>2023-04-15T04:34:04.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>&quot;The development of full artificial intelligence could spell the end of the human race.&quot;   - Stephen Hawking</p>
</blockquote>
<hr>
<p>因为 ChatGPT 的原因，最近各种 AI 概念真的很火 XD。</p>
<p>自己手头也正好有一台主机闲置，正好自建一个 StableDiffusion 来玩。</p>
<p>这篇文章可能会持续更新 (如果我有时间)，我会在这篇文章中分享整个过程。</p>
<hr>
<h2 id="部署背景">💭 部署背景</h2>
<p>因为平时会玩游戏，所以主机环境为 Windows10。</p>
<p>加上硬盘也不大，懒得去搞 Ubuntu 双系统了。所以目前的想法是直接部署一套 WebUI，</p>
<p>开放给同局域网下的 Mac 使用。这样主机就可以开着不管，所有操作都使用 Mac 完成。</p>
<p>跑完后再去 Windows 下提取跑出来的图片。</p>
<blockquote>
<p>顺带一提，Windows 和 Mac 文件互通确实是件很头疼的事情...</p>
</blockquote>
<hr>
<h2 id="主机配置">🪴 主机配置</h2>
<ul>
<li>
<p>CPU: <strong>Intel 12700KF</strong></p>
</li>
<li>
<p>内存: <strong>32G 双通道 DDR4</strong></p>
</li>
<li>
<p>显卡：<strong>RTX 3080 10G DDR6X</strong></p>
</li>
<li>
<p>... (更多的就懒得写了，和 SD 基本也没太多关系)</p>
</li>
</ul>
<blockquote>
<p>如果显卡显存低于 4G 可能会比较吃力 🫠，建议使用 <a href="https://colab.research.google.com/">Google Colab</a> 这类云服务来跑渲染。</p>
</blockquote>
<hr>
<h2 id="部署-stablediffusion">🍻 部署 StableDiffusion</h2>
<p>因为我真的很讨厌 Windows 下的编程环境，一点都不想在 Windows 下折腾。</p>
<p>所以我直接用了比较成熟的 WebUI： <a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui">AUTOMATIC1111/stable-diffusion-webui</a>。</p>
<p>当然，如果喜欢折腾的话也可以自己去 Clone <a href="https://github.com/Stability-AI/stablediffusion">源码</a>编译用 Shell 跑。</p>
<p>整个安装过程还是比较简单的，跟着 README 走即可。</p>
<ol>
<li>
<p>安装 Python 和 Git. (Python 要记得加 Path)。</p>
</li>
<li>
<p>Clone WebUI 到本地 <code>git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git</code></p>
</li>
<li>
<p>打开 Clone 下来的项目文件夹，双击 <code>webui-user.bat</code> 启动。</p>
</li>
</ol>
<p>第一次运行需要安装对应的依赖和库，一般需要等 20 ~ 30 分钟。同时，你需要科学上网。</p>
<p>等待安装完成启动后，访问 <code>127.0.0.1.7860</code> 即可使用。</p>
<hr>
<h2 id="常见问题">🍓 常见问题</h2>
<p>遇到问题可以先查阅官方提供的 <a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Troubleshooting">Wiki</a>。</p>
<h3 id="1-主机服务开放局域网访问">1. 主机服务开放局域网访问</h3>
<p>为了使局域网内的电脑可以访问本机服务，你可以做以下设置:</p>
<ol>
<li>
<p><strong>关闭 Windows 防火墙</strong></p>
<p>在 <code>设置</code> - <code>Windows 安全中心</code> - <code>防火墙和网络保护</code> 中关闭你的防火墙。</p>
<blockquote>
<p>当然，这种方法其实是有一定风险的，你也可以使用 <a href="https://www.jianshu.com/p/642be9f0a597">添加入站规则</a>的方式</p>
</blockquote>
</li>
<li>
<p><strong>修改 StableDiffusionWebUI 启动参数</strong></p>
<p>使用文本编辑工具打开 WebUI 目录下的 <code>webui-user.bat</code>，添加如下参数：</p>
<pre><code>set COMMANDLINE_ARGS=--listen --share --no-gradio-queue --enable-insecure-extension-access
</code></pre>
<blockquote>
<p>前两个参数是为了局域网可以正常访问服务，后两个参数解决非本机无法安装拓展的问题。</p>
</blockquote>
</li>
</ol>
<h3 id="2-webui-用户界面的汉化">2. WebUI 用户界面的汉化</h3>
<p>虽然全是名词，但是汉化成中文还是用起来会方便一些。</p>
<p>直接安装这个 Extension 即可完成汉化：<a href="https://github.com/VinsonLaro/stable-diffusion-webui-chinese">VinsonLaro/stable-diffusion-webui-chinese</a></p>
<blockquote>
<p>顺带一提，使用 Chinese-English 会更好一些，有些名词翻译后还是比较迷惑的。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[🪴 绕过 Cloudflare 访问 Valorant Api]]></title>
        <id>https://seaony.github.io/post/laravel-rao-guo-cloudflare-fang-huo-qiang-fang-wen-valorant-nei-bu-api/</id>
        <link href="https://seaony.github.io/post/laravel-rao-guo-cloudflare-fang-huo-qiang-fang-wen-valorant-nei-bu-api/">
        </link>
        <updated>2023-04-06T18:46:08.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文章所实现内容仅做学习分享所用，本人不承担任何责任，请勿将相关信息用于非法用途。</p>
</blockquote>
<h1 id="准备工作">🫠 准备工作</h1>
<p>首先，安装 <a href="https://github.com/guzzle/guzzle">GuzzleHttp</a> 网络请求 Package。</p>
<pre><code class="language-shell">composer require guzzlehttp/guzzle
</code></pre>
<hr>
<h1 id="绕过-cloudflare">💭 绕过 Cloudflare</h1>
<p>Valorant Api 受到 Cloudflare 防护，以及 Riot 也加了一层验证。</p>
<p>绕过 Cloudflare 的核心原理是使用 <code>Ciphers</code> 伪造 SSL，具体请求方式如下：</p>
<pre><code class="language-php"> /**
* 用于绕过 Riot 防护的请求头
*
* @var string[] 请求头
*/
$headers = [
    'Content-Type'          =&gt; 'application/json',
    'User-Agent'            =&gt; 'RiotClient/63.0.5.4887690.4789131 rso-auth (Windows; 10;;Professional, x64)',
    'X-Riot-ClientPlatform' =&gt; 'ew0KCSJwbGF0Zm9ybVR5cGUiOiAiUEMiLA0KCSJwbGF0Zm9ybU9TIjogIldpbmRvd3MiLA0KCSJwbGF0Zm9ybU9TVmVyc2lvbiI6ICIxMC4wLjE5MDQyLjEuMjU2LjY0Yml0IiwNCgkicGxhdGZvcm1DaGlwc2V0IjogIlVua25vd24iDQp9',
];

/**
* 请求中绕过 Cloudflare 所需要的 SSL 证书加密方式
*
* @var string[] 用于请求的参数
*/
$ciphers13 = [
    'TLS_CHACHA20_POLY1305_SHA256',
    'TLS_AES_128_GCM_SHA256',
    'TLS_AES_256_GCM_SHA384',
];

/**
* 请求中绕过 Cloudflare 所需要的 SSL 证书加密方式
*
* @var string[] 用于请求的参数
*/
$ciphers = [
    'ECDHE-ECDSA-CHACHA20-POLY1305',
    'ECDHE-RSA-CHACHA20-POLY1305',
    'ECDHE-ECDSA-AES128-GCM-SHA256',
    'ECDHE-RSA-AES128-GCM-SHA256',
    'ECDHE-ECDSA-AES256-GCM-SHA384',
    'ECDHE-RSA-AES256-GCM-SHA384',
    'ECDHE-ECDSA-AES128-SHA',
    'ECDHE-RSA-AES128-SHA',
    'ECDHE-ECDSA-AES256-SHA',
    'ECDHE-RSA-AES256-SHA',
    'AES128-GCM-SHA256',
    'AES256-GCM-SHA384',
    'AES128-SHA',
    'AES256-SHA',
    'DES-CBC3-SHA',  # most likely not available
];

// 实例化 HttpClient
 $client = new \GuzzleHttp\Client([
    'cookies' =&gt; true, // 开启 Cookie，保存 Riot 返回的 Token
    'curl'    =&gt; [
        CURLOPT_SSLVERSION      =&gt; CURL_SSLVERSION_TLSv1_3,
        CURLOPT_SSL_CIPHER_LIST =&gt; implode(':', $ciphers),
        CURLOPT_TLS13_CIPHERS   =&gt; implode(':', $ciphers13),
    ],
]);

// 发送请求
$response = $client-&gt;request('POST', 'https://auth.riotgames.com/api/v1/authorization', [
    'json' =&gt; [
        'client_id'             =&gt; 'riot-client',
        'code_challenge'        =&gt; '',
        'code_challenge_method' =&gt; '',
        'acr_values'            =&gt; '',
        'claims'                =&gt; '',
        'nonce'                 =&gt; '69420',
        'redirect_uri'          =&gt; 'http://localhost/redirect',
        'response_type'         =&gt; 'token id_token',
        'scope'                 =&gt; 'openid link ban lol_region',
    ],
]);

// do something
</code></pre>
<hr>
<h1 id="reference-links">👨‍💻 Reference Links</h1>
<ul>
<li><a href="https://github.com/techchrism/valorant-api-docs">techchrism/valorant-api-docs</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[👨‍💻 iOS 项目中使用自定义字体]]></title>
        <id>https://seaony.github.io/post/ios-xiang-mu-zhong-dao-ru-zi-ding-yi-zi-ti/</id>
        <link href="https://seaony.github.io/post/ios-xiang-mu-zhong-dao-ru-zi-ding-yi-zi-ti/">
        </link>
        <updated>2023-03-27T21:33:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="全局加载字体">🪴 全局加载字体</h1>
<h2 id="1-导入字体文件">1. 导入字体文件</h2>
<p>准备好要使用的字体文件，并且将它导入至你的 XCode Project 中。</p>
<blockquote>
<p>Tips：一定要勾选 <code>Copy items if needed</code> ，不勾选的话只会进行位置引用。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://seaony.github.io/post-images/1679953001044.png" alt="" loading="lazy"></figure>
<hr>
<h2 id="2-修改-infoplist">2. 修改 Info.plist</h2>
<p>打开你的 <code>Info.plist</code> 文件，新增一项：<code>Fonts provided by application</code>。</p>
<p>对应的值即为你的字体文件的名称 (不需要带 Group 前缀，需要带文件后缀)。</p>
<figure data-type="image" tabindex="2"><img src="https://seaony.github.io/post-images/1679953202754.png" alt="" loading="lazy"></figure>
<hr>
<h2 id="3-添加资源文件">3. 添加资源文件</h2>
<p>确保你的字体文件已添加至 <code>TARGETS</code> - <code>Build Phases</code> - <code>Copy Bundle Resources</code> 中。</p>
<blockquote>
<p>一般导入字体文件后会自动添加，但也会有意外 😃</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://seaony.github.io/post-images/1679953445072.png" alt="" loading="lazy"></figure>
<hr>
<h2 id="4-确认导入成功">4. 确认导入成功</h2>
<p>运行这段代码即可打印出所有可用字体，检查是否导入成功。</p>
<pre><code class="language-swift">for fontFamily in UIFont.familyNames {
    print(fontFamily)

    for font in UIFont.fontNames(forFamilyName: fontFamily) {
        print(fontFamily + &quot;: &quot; + font)
    }
}
</code></pre>
<hr>
<h1 id="覆盖默认字体">🧐 覆盖默认字体</h1>
<p>如果你需要全局都显示某个字体，那么就需要这样设置。</p>
<p>如果不这样做，那么你需要在每一个显示文本的地方都指定 <code>FontName</code>。</p>
<blockquote>
<p>Tips：使用覆盖 UIFont 的方式设置全局字体会导致键盘等系统 UI 字体也被替换。</p>
</blockquote>
<h2 id="1-创建-uifont-拓展">1. 创建 UIFont 拓展</h2>
<p>在 <code>Extension</code> Group 下创建 <code>UIFontExtension</code> 文件拓展 UIFont 类。</p>
<blockquote>
<p>当然，你也可以放在别的位置，使用其他名称 🫠。</p>
</blockquote>
<pre><code class="language-swift">import UIKit

// MARK: - AppFontName
struct AppFontName {
    static let italic = &quot;Montserrat-Medium&quot;
    static let regular = &quot;Montserrat-Medium&quot;
    static let semibold = &quot;Montserrat-SemiBold&quot;
    static let bold = &quot;Montserrat-Bold&quot;
    static let heavy = &quot;Montserrat-ExtraBold&quot;
    static let black = &quot;Montserrat-Black&quot;
}

// MARK: - UIFontDescriptor.AttributeName
extension UIFontDescriptor.AttributeName {

    /// NSCTFontUIUsageAttribute
    static let nsctFontUIUsage = UIFontDescriptor.AttributeName(rawValue: &quot;NSCTFontUIUsageAttribute&quot;)

}

/// 字体扩展
extension UIFont {

    /// 是否已经替换过
    static var isOverrided: Bool = false

    // 重写系统字体
    @objc class func mySystemFont(ofSize size: CGFloat, weight: UIFont.Weight) -&gt; UIFont {
        switch weight {
        case .ultraLight, .thin, .light, .regular, .medium:
            return UIFont(name: AppFontName.regular, size: size)!
        case .semibold:
            return UIFont(name: AppFontName.semibold, size: size)!
        case .bold:
            return UIFont(name: AppFontName.bold, size: size)!
        case .heavy:
            return UIFont(name: AppFontName.heavy, size: size)!
        case .black:
            return UIFont(name: AppFontName.black, size: size)!
        default:
            return UIFont(name: AppFontName.regular, size: size)!
        }
    }

    // 重写粗体字体
    @objc class func myBoldSystemFont(ofSize size: CGFloat) -&gt; UIFont {
        return UIFont(name: AppFontName.bold, size: size)!
    }

    // 重写斜体字体
    @objc class func myItalicSystemFont(ofSize size: CGFloat) -&gt; UIFont {
        return UIFont(name: AppFontName.italic, size: size)!
    }

    // 重写字体的编码方法
    @objc convenience init(myCoder aDecoder: NSCoder) {
        guard
                let fontDescriptor = aDecoder.decodeObject(forKey: &quot;UIFontDescriptor&quot;) as? UIFontDescriptor,
                let fontAttribute = fontDescriptor.fontAttributes[.nsctFontUIUsage] as? String
        else {
            self.init(myCoder: aDecoder)
            return
        }
        var fontName = &quot;&quot;
        switch fontAttribute {
        case &quot;CTFontRegularUsage&quot;:
            fontName = AppFontName.regular
        case &quot;CTFontEmphasizedUsage&quot;, &quot;CTFontBoldUsage&quot;:
            fontName = AppFontName.bold
        case &quot;CTFontObliqueUsage&quot;:
            fontName = AppFontName.italic
        default:
            fontName = AppFontName.regular
        }
        self.init(name: fontName, size: fontDescriptor.pointSize)!
    }

    /// 替换系统字体
    class func overrideInitialize() {

        // 避免 method swizzling 运行两次
        guard self == UIFont.self, !isOverrided else {
            return
        }

        // 避免 method swizzling 运行两次并恢复到原始初始化函数
        isOverrided = true

        // 替换系统字体
        if let systemFontMethod = class_getClassMethod(self, #selector(systemFont(ofSize:weight:))),
           let mySystemFontMethod = class_getClassMethod(self, #selector(mySystemFont(ofSize:weight:))) {
            method_exchangeImplementations(systemFontMethod, mySystemFontMethod)
        }

        // 替换粗体字体
        if let boldSystemFontMethod = class_getClassMethod(self, #selector(boldSystemFont(ofSize:))),
           let myBoldSystemFontMethod = class_getClassMethod(self, #selector(myBoldSystemFont(ofSize:))) {
            method_exchangeImplementations(boldSystemFontMethod, myBoldSystemFontMethod)
        }

        // 替换斜体字体
        if let italicSystemFontMethod = class_getClassMethod(self, #selector(italicSystemFont(ofSize:))),
           let myItalicSystemFontMethod = class_getClassMethod(self, #selector(myItalicSystemFont(ofSize:))) {
            method_exchangeImplementations(italicSystemFontMethod, myItalicSystemFontMethod)
        }

        // Trick to get over the lack of UIFont.init(coder:))
        if let initCoderMethod = class_getInstanceMethod(self, #selector(UIFontDescriptor.init(coder:))),
           let myInitCoderMethod = class_getInstanceMethod(self, #selector(UIFont.init(myCoder:))) {
            method_exchangeImplementations(initCoderMethod, myInitCoderMethod)
        }
    }
}
</code></pre>
<hr>
<h2 id="2-覆盖初始化方法">2. 覆盖初始化方法</h2>
<p>在你的 <code>AppDelegate</code> 文件中注册如下方法，覆盖 UIFont 初始化。</p>
<pre><code class="language-swift">override init() {
    super.init()
    UIFont.overrideInitialize()
}
</code></pre>
<hr>
<h1 id="reference-links">🫠 Reference Links</h1>
<ul>
<li>
<p><a href="https://medium.com/fabcoding/set-default-custom-font-for-entire-app-swift-5-55709e36e6f3">Set default custom font for entire app — Swift 5</a></p>
</li>
<li>
<p><a href="https://medium.com/@arunvaishy1007/setting-up-custom-font-style-for-text-labels-and-buttons-globally-in-ios-application-ios-swift-17b08317c026">Setting up custom font style for Text, Labels and Buttons globally in iOS Application — iOS Swift</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[🪴 Xcode 中创建纯代码布局项目]]></title>
        <id>https://seaony.github.io/post/hello-gridea/</id>
        <link href="https://seaony.github.io/post/hello-gridea/">
        </link>
        <updated>2023-03-22T16:03:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-移除-storyboard">🧐 1. 移除 Storyboard</h1>
<p>没什么好说的，既然是纯代码布局，那么 Storyboard 文件就不需要了。</p>
<pre><code class="language-shell">rm ./Main.storyboard
</code></pre>
<hr>
<h1 id="2-修改-main-interface">👨‍💻 2. 修改 Main Interface</h1>
<p>因为 Xcode 版本更新，不同的版本会有不同的处理方案。</p>
<ul>
<li>
<p>Xcode Version &lt; <strong>14.0</strong></p>
<p>清空 <code>General</code> - <code>Deployment Info</code> - <code>Main Interface</code>。</p>
</li>
<li>
<p>Xcode Version &gt;= <strong>14.0</strong></p>
<p>清空 <code>Build Setting</code> - <code>UIKit Main Storyboard File Base Name</code>。</p>
</li>
</ul>
<hr>
<h1 id="3-设置默认-view">🪴 3. 设置默认 View</h1>
<p>在你的 <code>AppDelegate.swift</code> - <code>application</code> 中添加如下代码。</p>
<pre><code class="language-swift">// 设置默认显示的界面
let controller = YourDefaultViewController()
        
self.window = UIWindow(frame: UIScreen.main.bounds)
window!.rootViewController = UINavigationController(rootViewController: controller)
window?.makeKeyAndVisible()
</code></pre>
]]></content>
    </entry>
</feed>